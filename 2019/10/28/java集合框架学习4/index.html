<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>java集合框架学习4-以Abstract开头的抽象类 | 格物才可致知</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言在之前，我讨论了几个较为基础的接口，这几个接口也是我们日常比较常见到的，用到的；也是数据结构这门课强调最为多的几个接口。 而这次这几个接口会成为抽象类，也就是说直接实现了我前面讨论了的接口的抽象类。 接下来就直接进入正题了。 被实现为Abstract抽象类的基础数据结构 Collection List Map Queue SequentialList Set  从以上的数据结构类型可以看出，在">
<meta property="og:type" content="article">
<meta property="og:title" content="java集合框架学习4-以Abstract开头的抽象类">
<meta property="og:url" content="http://yoursite.com/2019/10/28/java集合框架学习4/index.html">
<meta property="og:site_name" content="格物才可致知">
<meta property="og:description" content="前言在之前，我讨论了几个较为基础的接口，这几个接口也是我们日常比较常见到的，用到的；也是数据结构这门课强调最为多的几个接口。 而这次这几个接口会成为抽象类，也就是说直接实现了我前面讨论了的接口的抽象类。 接下来就直接进入正题了。 被实现为Abstract抽象类的基础数据结构 Collection List Map Queue SequentialList Set  从以上的数据结构类型可以看出，在">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2019-10-28T06:30:47.559Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java集合框架学习4-以Abstract开头的抽象类">
<meta name="twitter:description" content="前言在之前，我讨论了几个较为基础的接口，这几个接口也是我们日常比较常见到的，用到的；也是数据结构这门课强调最为多的几个接口。 而这次这几个接口会成为抽象类，也就是说直接实现了我前面讨论了的接口的抽象类。 接下来就直接进入正题了。 被实现为Abstract抽象类的基础数据结构 Collection List Map Queue SequentialList Set  从以上的数据结构类型可以看出，在">
  
    <link rel="alternate" href="/atom.xml" title="格物才可致知" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <div id="feologo"></div>
        <a href="/" id="logo">格物才可致知</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
<!--         
          <a href="/categories/java" class="main-nav-link">java</a>
        
          <a href="/categories/哲学" class="main-nav-link">哲学</a>
        
          <a href="/categories/外语学习" class="main-nav-link">外语学习</a>
        
          <a href="/categories/数据库设计" class="main-nav-link">数据库设计</a>
        
          <a href="/categories/视图模板技术" class="main-nav-link">视图模板技术</a>
        
          <a href="/categories/计算机基础" class="main-nav-link">计算机基础</a>
        
          <a href="/categories/软件开发方法" class="main-nav-link">软件开发方法</a>
        
          <a href="/categories/软件构造思想" class="main-nav-link">软件构造思想</a>
        
          <a href="/categories/软件测试" class="main-nav-link">软件测试</a>
        
          <a href="/categories/软件质量" class="main-nav-link">软件质量</a>
        
          <a href="/categories/面向对象设计" class="main-nav-link">面向对象设计</a>
         -->
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-java集合框架学习4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/28/java集合框架学习4/" class="article-date">
  <time datetime="2019-10-27T16:39:56.842Z" itemprop="datePublished">2019-10-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      java集合框架学习4-以Abstract开头的抽象类
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在之前，我讨论了几个较为基础的接口，这几个接口也是我们日常比较常见到的，用到的；也是数据结构这门课强调最为多的几个接口。</p>
<p>而这次这几个接口会成为抽象类，也就是说直接实现了我前面讨论了的接口的抽象类。</p>
<p>接下来就直接进入正题了。</p>
<h3 id="被实现为Abstract抽象类的基础数据结构"><a href="#被实现为Abstract抽象类的基础数据结构" class="headerlink" title="被实现为Abstract抽象类的基础数据结构"></a>被实现为Abstract抽象类的基础数据结构</h3><ul>
<li>Collection</li>
<li>List</li>
<li>Map</li>
<li>Queue</li>
<li>SequentialList</li>
<li>Set</li>
</ul>
<p>从以上的数据结构类型可以看出，在我之前讨论过的基础数据结构的接口来说，除了接口Dequq，抽象类Dictionary，具体类Stack之外，接口定义都实现为了抽象类。而且还加了个SequentialList的抽象类。</p>
<p>而在上面显示的数据结构，大门的继承接口和相互之间的继承关系又如下：</p>
<p>AbstractCollection</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractCollection&lt;E&gt;</span><br><span class="line">  extends Object</span><br><span class="line">  implements Collection&lt;E&gt;</span><br></pre></td></tr></table></figure>

<p>AbstractList</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractList&lt;E&gt;</span><br><span class="line">  extends AbstractCollection&lt;E&gt;</span><br><span class="line">  implements List&lt;E&gt;</span><br></pre></td></tr></table></figure>

<p>AbstractMap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractMap&lt;K, V&gt;</span><br><span class="line">  extends Object</span><br><span class="line">  implements Map&lt;K, V&gt;</span><br></pre></td></tr></table></figure>

<p>AbstractQueue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractQueue&lt;E&gt;</span><br><span class="line">  extends AbstractCollection&lt;E&gt;</span><br><span class="line">  implements Queue&lt;E&gt;</span><br></pre></td></tr></table></figure>

<p>AbstractSequentialList</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractSequentialList&lt;E&gt;</span><br><span class="line">  extends AbstractList&lt;E&gt;</span><br></pre></td></tr></table></figure>

<p>AbstractSet</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractSet&lt;E&gt;</span><br><span class="line">  extends AbstractCollection&lt;E&gt;</span><br><span class="line">  implements Set&lt;E&gt;</span><br></pre></td></tr></table></figure>

<p>从以上列出的定义可以看出，除了AbstractMap，其他抽象类都继承自AhstractCollection。所以都具有AbstractCollection的实现。</p>
<h3 id="AbstractCollection"><a href="#AbstractCollection" class="headerlink" title="AbstractCollection"></a>AbstractCollection</h3><p>此个抽象类继承自Object对象，而且除了iterator方法和size方法定义为未实现的抽象方法，都实现了其他类接口Collection的全部接口方法。方法的定义都放在了接口中了，所以此时具体的类定义，如果没有具体实现的，便定义为抽象方法，如果有具体定义的，便定义为非抽象方法。</p>
<p>值得注意（对面向对象的类方法定义和实现和继承是有借鉴意义的）：</p>
<ol>
<li>新定义了接口中没有的方法，覆盖了继承的Object类里面的toString方法；</li>
<li>定义了个内部私有实现方法来供toArray公有方法使用，如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static &lt;T&gt; T[] finishToArray(T[] paramArrayOfT, Iterator&lt;?&gt; paramIterator)</span><br></pre></td></tr></table></figure>

<p>对于具体的实现的接口方法是什么，请看之前的接口分析。而方法的具体实现内部逻辑，并不是我今天讨论的重点。</p>
<h3 id="AbstractList，AbstractQueue，AbstractSet"><a href="#AbstractList，AbstractQueue，AbstractSet" class="headerlink" title="AbstractList，AbstractQueue，AbstractSet"></a>AbstractList，AbstractQueue，AbstractSet</h3><p>这几个抽象类对应的接口分别是我之前已经讨论过的List，Queue，Set接口。</p>
<p>而且这几个抽象类都有一个共同点，就是继承自AbstractCollection抽象类。也就是说，作者在实现各自接口的抽象类之前，除了将实现接口当成是一个任务，而且在设计上，将其共性都放置到AbstractCollection抽象类中。</p>
<h5 id="AbstractList"><a href="#AbstractList" class="headerlink" title="AbstractList"></a>AbstractList</h5><p>这个类的实现基本操作有和List接口定义的大致一样，需要请看之前的List接口博文。</p>
<p>重点有几个：</p>
<ol>
<li>对于没定义为抽象方法，但在接口中已经申明定义的方法，具体定义都以抛出一个异常作为实现。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public E xxx(xxx xxx) &#123; throw new UnsupportedOperationException(); &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义有一个removeRange方法，访问形式申明为protected，并让共有方法clear调用，我的猜想是：想让clear的具体实现封装在类继承体系内，也就是说，子类可以通过继承removeRange重新定义，实现对clear方法实现的更改。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void clear() &#123; removeRange(0, size()); &#125;</span><br><span class="line">protected void removeRange(int paramInt1, int paramInt2) &#123;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如果定义为私有方法的，必定是被公有方法调用，而不曝露给调用者。如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void rangeCheckForAdd(int paramInt) &#123;</span><br><span class="line">  if (paramInt &lt; 0 || paramInt &gt; size()) &#123;</span><br><span class="line">    throw new IndexOutOfBoundsException(outOfBoundsMsg(paramInt));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private String outOfBoundsMsg(int paramInt) &#123; return &quot;Index: &quot; + paramInt + &quot;, Size: &quot; + size(); &#125;</span><br><span class="line"></span><br><span class="line">public ListIterator&lt;E&gt; listIterator(int paramInt) &#123;</span><br><span class="line">  rangeCheckForAdd(paramInt);</span><br><span class="line">  </span><br><span class="line">  return new ListItr(paramInt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>令人诧异的是，一个抽象类的内部竟然还有一个私有类的定义：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private class Itr</span><br><span class="line">  extends Object</span><br><span class="line">  implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，应该是一个Iterator和ListIterator接口的自身内部实现，也就是说，自己内部定义了接口的类实现，而且只供此类内部的方法逻辑使用。</p>
<p>当然，内部类也不是我今天想讨论的重点。</p>
<h5 id="AbstractQueue"><a href="#AbstractQueue" class="headerlink" title="AbstractQueue"></a>AbstractQueue</h5><p>这个类的定义还是比较清楚的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E paramE) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">public E remove() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">public E element() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">public void clear() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">public boolean addAll(Collection&lt;? extends E&gt; paramCollection) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>但是有很疑惑的一点，便是Queue的接口定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123;</span><br><span class="line">  boolean add(E paramE);</span><br><span class="line">  </span><br><span class="line">  boolean offer(E paramE);</span><br><span class="line">  </span><br><span class="line">  E remove();</span><br><span class="line">  </span><br><span class="line">  E poll();</span><br><span class="line">  </span><br><span class="line">  E element();</span><br><span class="line">  </span><br><span class="line">  E peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么offer，poll和peek方法的定义哪里去了？实现接口，却没实现相应的接口方法，而且居然还没报错？</p>
<p>想了一想，还是暂且放一边吧。但是有一点，就是继承自AbstractQueue的类定义是有定义以上抽象类没有定义的接口的。这个问题也暂且当成是个疑问吧。</p>
<h5 id="AbstractSet"><a href="#AbstractSet" class="headerlink" title="AbstractSet"></a>AbstractSet</h5><p>和AbstractQueue一样，这个抽象类的定义也比较简单，只有三个方法的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object paramObject) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">public int hashCode() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">public boolean removeAll(Collection&lt;?&gt; paramCollection) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>而且我们又发现问题了。便是Set接口里面的一大堆方法几乎都没有实现的定义，连申明都没有。。。和上面的问题其实是一样的，也是我暂且我想得知的。</p>
<h3 id="AbstractSequentialList"><a href="#AbstractSequentialList" class="headerlink" title="AbstractSequentialList"></a>AbstractSequentialList</h3><p>这个类从以上申明可以知道，是继承自AbstractList抽象类的，其内部方法定义实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public E get(int paramInt) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">public E set(int paramInt, E paramE) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">public void add(int paramInt, E paramE) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">public E remove(int paramInt) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">public boolean addAll(int paramInt, Collection&lt;? extends E&gt; paramCollection) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">public Iterator&lt;E&gt; iterator() &#123; return listIterator(); &#125;</span><br><span class="line"></span><br><span class="line">public abstract ListIterator&lt;E&gt; listIterator(int paramInt);</span><br></pre></td></tr></table></figure>

<p>可以看出，有一些，如get，set，add，remove是对AbstractList实现的完善，一些是自己对AbstractList实现的方法的重写，如addAll。或者是有一些方法是对子类方法的适配，如iterator。</p>
<h3 id="AbstractMap"><a href="#AbstractMap" class="headerlink" title="AbstractMap"></a>AbstractMap</h3><p>这个抽象类是实现Map接口，而且是Object的直接子类。</p>
<p>这个抽象子类的实现功能大体和Map接口定义的方法一样，但有几个除了公有接口方法的实现之外，还有几个发现：</p>
<ol>
<li>私有的静态方法实现：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static boolean eq(Object paramObject1, Object paramObject2) &#123; return (paramObject1 == null) ? ((paramObject2 == null)) : paramObject1.equals(paramObject2); &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>未实现的接口方法定义：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>公有内部静态类定义：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static class SimpleEntry&lt;K, V&gt;</span><br><span class="line">  extends Object</span><br><span class="line">  implements Map.Entry&lt;K, V&gt;, Serializable &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">public static class SimpleImmutableEntry&lt;K, V&gt;</span><br><span class="line">  extends Object</span><br><span class="line">  implements Map.Entry&lt;K, V&gt;, Serializable &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>实现的是Map接口内的公有静态接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static interface Entry&lt;K, V&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>大概的意思和作用应该是，Map代表键值列表的操作，而entry代表单个键值对的操作。具体的内部思想和实现今天不讨论。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过以上的大概的了解，得知几个重要接口的抽象类实现的大致。</p>
<p>作用有几个：</p>
<ol>
<li>清楚了抽象类的继承关系；</li>
<li>清楚了抽象类对接口的实现大概脉络；</li>
<li>了解了面向对类库抽象类设计的一些特性，比如访问性，内部接口，内部类，继承机制下方法的重写等；</li>
<li>发现了一些以前不知道的问题：接口定义的方法可以不在一级继承接口的方法内实现？</li>
</ol>
<p>问题需要以后去解决，今天先到这。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/28/java集合框架学习4/" data-id="ck2hx5gtk002o38v5w3fd68k8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/10/29/操作系统学习1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          操作系统学习-进程与线程1
        
      </div>
    </a>
  
  
    <a href="/2019/10/27/java输入输出学习1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">java输入输出学习1</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/哲学/">哲学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/外语学习/">外语学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库设计/">数据库设计</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图模板技术/">视图模板技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/">计算机基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/软件开发方法/">软件开发方法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/软件构造思想/">软件构造思想</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/软件测试/">软件测试</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/软件质量/">软件质量</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/面向对象设计/">面向对象设计</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">时间</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/11/02/spring学习2/">spring初识2</a>
          </li>
        
          <li>
            <a href="/2019/11/01/spring学习1/">spring初识1</a>
          </li>
        
          <li>
            <a href="/2019/10/31/自我认知与批判1/">自我认知与批判1</a>
          </li>
        
          <li>
            <a href="/2019/10/31/实践哲学/">人生哲学</a>
          </li>
        
          <li>
            <a href="/2019/10/30/java线程学习3/">java线程学习3-线程执行器与线程池</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 feomouse<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
<!--   
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
   -->
  
    <a href="/categories/java" class="mobile-nav-link">java</a>
  
    <a href="/categories/哲学" class="mobile-nav-link">哲学</a>
  
    <a href="/categories/外语学习" class="mobile-nav-link">外语学习</a>
  
    <a href="/categories/数据库设计" class="mobile-nav-link">数据库设计</a>
  
    <a href="/categories/视图模板技术" class="mobile-nav-link">视图模板技术</a>
  
    <a href="/categories/计算机基础" class="mobile-nav-link">计算机基础</a>
  
    <a href="/categories/软件开发方法" class="mobile-nav-link">软件开发方法</a>
  
    <a href="/categories/软件构造思想" class="mobile-nav-link">软件构造思想</a>
  
    <a href="/categories/软件测试" class="mobile-nav-link">软件测试</a>
  
    <a href="/categories/软件质量" class="mobile-nav-link">软件质量</a>
  
    <a href="/categories/面向对象设计" class="mobile-nav-link">面向对象设计</a>
  
</nav>
    

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>