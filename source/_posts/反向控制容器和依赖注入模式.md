---
title: 反向控制容器和依赖注入模式
categories: 软件构造思想
---

### 原作者

* Martin Fowler

### 原文链接

https://martinfowler.com/articles/injection.html

### 序

在java社区，有很多帮助我们将多个来自不同项目的组件组装成单个内聚一致的应用程序的轻量级容器。
下面这些容器的启动使用是一种以共同的模式，一种名叫“控制反转”的概念的应用。在这篇文章中，我深入
挖掘这种模式是怎么工作的，在一个更具体的，特指的名字“控制反转”下，并且和服务定位转换器一起组成协议。容器之间的选择并不是重点，将其应用到分离配置的原则才是重点。

在企业级java的世界中，一个有趣的事情便是存在大量的对于主流j2ee技术的构建选择的活动，而且大多是开源的。占大多数的技术是对重量级，复杂的主流j2ee世界的回应，但是其中仍有很多技术是在探索多种不一样的选择，而且也产生了许多创造性的点子。一个普遍的问题便是，怎么同时启用不同的影响元素：怎么在相互了解很少的不同团队间协调好web控制器架构和相应的数据库接口。很多框架使用了stab在这个问题中，还有一些分离出来，提供了一个更加普遍的能力将不同层次的组件组装在一起。这些框架常被当成是轻量级的容器，例如PicoContainer和Spring。

在这些容器之下是一些有趣的设计原则，而在这些指定的容器之上，其实是java平台。这里我想开始探索一些里面的原则。这些例子使用的是java，但是我写的大多数原则是可以同等运用到其他面向对象的环境，特别是.net。

### 组件和服务

连接多个不同的元素到一起的这个问题马上将我拉入到围绕服务和组件的复杂的术语问题中来。你会发现
很容易发现一些在这个问题的定义上冗长的，相互矛盾的文章。就我的目的来说，这里是我当前的运用。

我使用组件这个名称来表示我想要使用的大量的软件，不改变其内容，对于不在作者控制下应用里的组件来说。就“不改变”来说，我指的是使用应用而不用改变其组建的源代码，即使会通过组件作者允许的情况下拓展组件使其改变组件的行为。

一个服务其实很像一个被外界应用程序使用的组件。其中主要的不同是我希望一个组件被本地使用(像是jar文件，程序集，dll，或者是一个源码导入)。一个服务是通过一些远程接口被远程使用，不管是同步还是异步(web服务，消息系统，远程过程调用，或者是套接字)。

我主要在这篇文章里使用服务，但是其中很多的相同的逻辑是可以被运用到本地的组件当中的。事实上，你经常需要一些本地组件框架来很容易地进入远程服务。但是总是写“组件或服务”很累，所以更多地使用服务这个名称来替代。

### 一个直接的例子

为了使我想要表达的概念更加具体，我会使用一个运行的例子来谈论这个概念。我的例子都是十分容易理解的例子；小到不真实，但是希望足够让你可以看见正在进行的事情，而不用研究一个真实的例子。

在这个例子中，我正在写一个能够提供一个被指定导演制作的电影的列表。这个十分有用的方法是通过一个单一的方法实现的。

```
class MovieLister...
   public Moviep[] moviesDirectedBy(String arg) {
     List allMovies = finder.findAll();
     for (Iterator it = allMovies.iterator(); it.hasNext();) {
       Movie movie = (Movie) it.next();
       if (!movie.getDirector().equals(arg)) it.remove();
     }
     return (Movie[]) allMovies.toArray(new Movie[allMovies.size()]);
   }
```
这个方法的实现是特别地直接的，这个方法命令一个查找者对象返回每一个其知道的电影。然后其只是遍历这个列表来返回那些被指定导演执导的电影。这个指定的直接的部分我不打算去修理，因为其只是这篇文章的重点的骨架。

这篇文章的重点是这个查找对象，或者是我们怎么列表对象和指定的查找对象连接起来。这个例子有趣的点是因为我想的有趣的moviesDirectedBy 方法可以和全部的电影是怎样的储存的给隔离开来。所以所有方法做的只是引用一个查找者，然后查找者知道的只是如何定义运用findAll方法，我可以通过为查找者定义一个接口将其提取出来。

```
public interface MovieFinder {
  List findAll();
}
```
现在全部都很好地解耦了，但是有时我不得不创造一个具体的类来实际上产生这些电影。在这个情况下，我将代码放在了我的列表类的构造函数里。

```
class MovieLister...
   private MovieFinder finder;
   public MovieLister() {
     finder = new ColonDelimitedMovieFinder("movie1.txt");
   }
```

这个实现的类的名字来自我是从冒号分隔的文本文件得到的。我现在先略去细节，毕竟现在只是有了一些实现。

现在如果我正在使用的类只是为了我自己，一切都很好。但是当我的朋友十分沉迷于其极妙的功能，同时想要一份我程序的副本，会发生什么呢？如果他们也想要储存将他们的电影列表用冒号分隔的名为“movies1.txt”文件中时，一切都很好。如果他们对这个电影文件有一个不同的名字的话，将文件的名字存为指定的文件也是很容易的。但是如果他们想要一个完全不同格式的方法来储存这些电影列表的话：一个SQL数据库，一个XML文件，一个web服务，或者只是另一个格式的文本文件呢？在这种情况下，我们需要一个不同的类来包裹处理这些文件。现在因为我已经定义了一个MovieFinder接口，这个不会改变我的moviesDirectedBy方法。但是在这个地方我依然需要有一些方法来获取正确的查找者实例的实现。

MovieLister类是依赖于MovieFinder接口和其接口实现类的。我们会使用它，如果他只是依赖于其接口，但是我们怎么制造一个来工作的实例呢？

在我的名叫P of EAA的书中，我们将这种情况描述为一个插件。在编译时，查找者类的实现没有被链接到程序中，因为我不知道我的朋友想要使用什么。然而我们想要我的lister和任何实现一起工作时，然后将实现在之后插入到程序中，而不经过我的手。这里的问题便是，我如何才能在我的lister类对其实现类是无知的情况下，但是却依然能和实例进行联系而进行工作。

拓展这个情况到真实的系统中时，我们可能有许多这样的服务和组件。在每个情况下，我们能够通过一个接口来和这些组件交流（还可以使用一个适配器，如果组件没有定义接口）。但是如果我们希望通过不同的方式来部署系统的话，我们需要使用插件来处理和这些服务的交互，所以我们可以使用不同的实现，在不同的部署方式下。

所以核心问题是我们如何将这些插件组装到一个应用程序中呢？这是这种新型轻量级的容器所面对的一个主要的问题，于是通常他们通过控制反转来实现。

### 控制反转

当这些容器总是谈论他们怎么有用，因为他们实现了“控制反转”的时候，我总是十分疑惑。控制反转框架的一个通用特性，所以说这些轻量级容器是特别的，因为他们使用的控制反转，就像是在说我的车因为有轮子而十分特殊。

问题是：“究竟在反转什么方面的控制？”当我得知控制反转时，是关于控制一个用户的接口。先前，用户的接口是被应用程序控制的。你会有一系列的命令，像是“输入名称”，“输入地址”；你的程序将会驱动这些提示，并为每一个提示选择一个回复。在图形化的ui和ui框架将会包含这个主要的循环，然后你的程序会为屏幕上很多的区域提供一个事件处理器，程序主要的控制被反转了，从你转移到了框架。

对于这种新的容器来说，反转是指怎样查找一个插件的实现。在我直接的例子中，lister通过直接实例化来查找finder的实现。这使finder无法成为一个插件。这些容器实现的方法，是为了确保任何插件的使用者遵循一些惯例，而允许分离的程序集模块能够注入到lister的实现中。

结果，我认为对于这种模式，我们需要一个更加特殊的名字。控制反转太宽泛了，因此人们觉得十分疑惑。结果，基于对大量的IoC容器的讨论，我们又定义了一个名称 依赖注入。

我将要通过讨论大量形式的依赖注入来开始，但是我会指出，这不是从应用程序类中移除对插件实现的依赖唯一的方法。另一种你可以使用的模式是服务定位器，我也会在讨论完依赖注入之后讨论它。

### 依赖注入的形式

依赖注入的基本概念是拥有分离的对象，一个组装器，产生在lister类中的一个域对于finder接口的一个合适的实现。

有三种主流的依赖注入的方法。我使用他们的名字是构造器注入，设置器注入，还有接口注入。如果你在当前的关于控制反转的讨论读到这些，你将会听到其为类型1 IoC，类型2 IoC，类型3 IoC。但这里我发现有很多名字很难被记住。

##### PicoContainer的构造器注入

我将会通过一个轻量级的叫做PicoContainer的容器展示这种注入。我在这里开始主要是因为一些在ThoughtWorks的我的同事对于PicoContainer的发展十分活跃。

PicoContainer使用构造器来决定怎么注入一个finder实现到lister类中。为了使例子工作，电影lister类需要描述一个构造器，其中包含需要注入的全部东西。

```
class MovieLister...
   public MovieLister(MovieFinder finder) {
     this.finder = finder;
   }
```

finder是被pico容器所管理的，所以会有指定文本文件的文件名被容器注入构造函数其中。

```
class ColonMovieFinder...
   public ColonMovieFinder(String filename) {
     this.filename = filename;
   }
```

pico容器需要被告知将哪一个实现类和哪一个接口联系，还有哪一个字符串被注入到finder。

```
private MutablePicoContainer configureContainer() {
  MutablePicoContainer pico = new DefaultPicoContainer();
  Parameter[] finderParams = {new ConstanParameter("movies1.txt")};
  pico.registerComponentImplementation(MovieFinder.class, ColonMovieFinder.class, finderParams);
  pico.registerComponentImplementation(MovieLister.class);
  return pico;
}
```

这个配置代码特别地设置到了不一样的类中。从我们的例子来说，每一个使用我的lister的朋友或许会在他们自己的设置代码中编写合适的配置代码。当然，把这些配置信息放到一个分离的配置文件中也是十分正常的。你可以编写一个类来阅读配置文件，同时以合适的方式设置容器。即使pico容器没有在其自身包含这个功能，但是也有一个紧密相关的名叫Nano容器的项目提供了合适的包裹器以允许你有xml配置文件。这个nano容器将会解析xml文件，然后配置pico容器。这个项目的哲学就是从背后的机制分离配置文件格式。

为了使用容器，你可以编写以下代码。

```
public void testWithPico() {
  MutablePicoContainer pico = configureContainer();
  MovieLister lister = (MovieLister) pico.getComponentInstance(MovieLister.class);
  Movie[] movies = lister.moviesDirectedBy("Sergio Leone");
  assertEquals("Once Upon a Time in the West", moviesp[0].getTitle());
}
```

即使这个例子中我使用了构造器注入，pico容器也支持设置器注入，即使开发者更喜欢构造器注入。

##### Spring设置器注入

Spring框架是一个范围很广的，对于企业级java开发的框架。其包含了对于事务的抽象层，持久层框架，web应用开发和JDBC。像是pico容器，其同时支持构造器和设置器注入，但是他的开发者更倾向于设置器注入-对于这个例子来说是一个很合适的选择。

为了得到我的电影lister来接收注入，我为服务定义了一个设置器方法。

```
class MovieLister...
   private MovieFinder finder;
   public void setFinder(MovieFinder finder) {
     this.finder = finder;
   }
```

相似的，我为文件名定义了一个设置器。

```
class ColonMovieFinder...
  public void setFilename(String filename) {
    this.filename = filename;
  }
```

第三步便是为文件设置配置文件。Spring支持通过XML文件和通过代码配置，但是XML是理想的方式来执行。

```
<beans>
    <bean id="MovieLister" class="spring.MovieLister">
        <property name="finder">
            <ref local="MovieFinder" />
        </property>
    </bean>
    <bean id="MovieFinder" class="spring.ColonMovieFinder">
        <property name="filename">
            <value>movies1.txt</value>
        </property>
    </bean>
</beans>
```

以下是测试。

```
public void testWithSpring() throws Exception {
  ApplicationContext ctx = new FileSystemXmlApplicationContext("spring.xml");
  MovieLister lister = (MovieLister) ctx.getBean("MovieLister");
  Movie[] movies = lister.movieDirectedBy("Sergio Leone");
  assertEquals("Once Upon a Time in the West", movies[0].getTitle());
} 
```

##### 接口注入

第三个注入机制便是定义和注入使用接口。Avalon就是一个应用这个机制的框架的例子。我将会之后讨论这个，但是在这里我将要应用到一些简单的样例代码中。

通过这种技术，我开始定义一个接口来展示注入。这里是一个接口来注入一个电影finder到一个对象中。

```
public interface InjectFinder {
  void injectFinder(MovieFinder finder);
}
```

这个接口被提供MovieFinder接口的人所定义。其需要被任何想使用finder的类实现，比如lister。

```
class MovieLister implements InjectFinder
   public void injectFinder(MovieFinder finder) {
     this.finder = finder;
   }
```

我使用一个相似的方法来注入文件名到finder的实现中。

```
public interface InjectFinderFilename {
  void injectFilename (String filename);
}
```

```
class ColonMovieFinder implements MovieFinder, InjectFinderFilename...
   public void injectFilename(String filename) {
     this.filename = filename;
   }
```

然后和往常一样，我需要一些配置代码来启用实现。为了简单些，我写到了代码里。

```
class Tester...
   private Container container;

   private void configureContainer() {
     container = new Container();
     registerComponents();
     registerInjectors();
     container.start();
   }
```

这个配置代码有两个阶段，通过查找主键来注册组件，和另一个例子十分相似。

```
class Tester...
   private void registerComponents() {
     container.registerComponent("MovieLister", MovieLister.class);
     container.registerComponent("NovieFinder", ColonMovieFinder.class);
   }
```

一个新的步骤是注册那个将会注入依赖组建的注入器。每一个注入器接口需要一些代码来注入依赖对象。这里我通过容器来注册注入器对象。每一个注入器对象实现了注入接口。

```
class Tester...
   private void registerInjectors() {
     container.registerInjector(InjectFinder.class, container.lookup("MovieFinder"));
     container.registerInjector(InjectFinderFilename. class, new FinderFilenameInjector());
   }
   public interface Injector {
     public void inject(Object target);
   }
```

当依赖对这个容器来说是一个类的话，组件自己实现注入接口就有道理了，就像这里的电影finder一样。对于一般类，像是字符串，我在配置代码里使用了内部类。

```
class ColonMovieFinder implements Injector...
   public void inject(Object target) {
     ((InjectFinder) target).injectFinder(this);
   }

class Test...
   public static class FinderFilenameInjector implements Injector {
     public void inject(Object target) {
       ((InjectFinderFilename)target).injectFilename("movies1.txt");
     }
   }
```

测试使用了容器。

```
class Tester...
   public void testIface() {
     configureContainer();
     MovieLister lister = (MovieLister)container.lookup("MovieLister");
     Movie[] movies = lister.moviesDirectedBy("Sergio Leone");
     assertEquals("Once Upon a Time in the West", movies[0].getTitle());
   }
```

容器使用了申明了的注入器接口来发现依赖，于是注入器可以注入正确的依赖。（我这里特定的容器实现在技术方面来说不重要，我也不会写出来，以防你嘲笑我）。

### 使用一个服务定位器

依赖注入最核心的好处是将MovieLister类对具体的MovieFinder的实现的依赖移除了。这样我就可以将listers给朋友，然后他们可以根据他们的环境来加入合适的实现。注入不是解除这种依赖的唯一的方法，另一个便是服务定位器。

服务定位器最基本的想法是拥有一个应用需要的，知道如何获取和拥有所有服务的对象。所以对于这个应用一个服务定位器将会拥有一个方法，可以再需要的时候返回一个电影。当然这个转移了一下负担，我们任然必须在lister里得到定位器。

在这个例子中，我将会使用服务定位器当成一个单例注册单位。lister能够在实例化之后用它来得到finder。

```
class MovieLister...
   MovieFinder finder = ServiceLocator.movieFindedr();

class ServiceLocator...
   public static MovieFinder movieFinder() {
     return soleInstance.movieFinder;
   }
   private static ServiceLocator soleInstance;
   private MovieFinder movieDinder;
```

为了注入，我们必须配置服务定位器。这里我写在代码里，但是使用一种机制从配置文件里读取合适的数据并不是太难。

```
class Tester...
   private void configure() {
     ServiceLocator.load(new ServiceLocator(new ColonMovieFinder("movies1.txt")));
   }

class ServiceLocator...
   public static void load(ServiceLocator arg) {
     soleInstance = arg;
   }

   public ServiceLocator(MovieFinder movieFinder) {
     this.movieFinder = movieFinder;
   }
```

测试代码。

```
class Tester...
   public void testSimple() {
     configure();
     MovieLister lister = new MovieLister();
     Movie[] movies = lister.moviesDirectedBy("Sergio Leone");
     assertEquals("Once Upon a Time in the West", movies[0].getTitle());
   }
```

我经常听到抱怨像是说这种服务定位器是坏的，因为他们不可测试，因为你不能代替他们实现。当然你可以设计成这种很坏的情况，但是你不必这样。在这个例子中，服务定位器实例只是一个单纯的数据保持者。我可以很容易地创建带测试实现的服务的定位者。

对于更加复杂的定位器来说，我可以创建服务定位器的子类然后传递子类到注册类的变量中。我可以将静态方法改变成实例方法，而不是直接访问实例变量。我可以通过线程指定储存来提供线程指定定位器。这些全部都可以完成而不用服务定位器的客户。

可以将服务定位器理解成一个注册机构而不是一个单例。一个单例提供一个容易的方法来实现一个注册机构，但是实现的决定是很容易改变的。

##### 为定位器使用一个隔离的接口

上面方法有一个问题，就是MovieLister是依赖与整个服务定位器类的，即使它只使用一个服务。我们可以通过角色接口减少整个服务定位器。lister可以只是申明他所要的接口，而不是整个服务定位器接口。

在这种情况下，lister的提供者，需要获得finder，将会提供定位器接口。

```
public interface MovieFinderLocator {
  public MovieFinder movieFinder();
}
```

定位器这时需要实现这个接口来提供finder的访问。

```
MovieFinderLocator locator = ServiceLocator.locator();
MovieFinder finder = locator.movieFinder();
public static ServiceLocator locator() {
  return soleInstance;
}
public MovieFinder movieFinder() {
  return movieFinder;
}
private static ServiceLocator soleInstance;
private MovieFinder movieFinder;
```

你将会注意到既然我们想要使用一个接口，我们不能只是通过静态方法访问服务。我们必须使用类来得到一个定位器实例，然后使用实例获取我们需要的。

##### 一个动态服务定位器

以上的例子是静态的，在那例子里面服务定位器类对于每个你需要的服务有方法。这不是唯一的方法，你也可以制造一个动态服务定位器来允许你藏匿任何你需要的服务到里面，然后在运行时创建你的选择。

在这种情况下，服务定位器对于每个服务使用了map而不是域，并提供了普通的方法来得到和加载服务。

```
class ServiceLocator...
   private static ServiceLocator soleInstance;
   public static void load(ServiceLocator arg) {
     soleInstance = arg;
   }
   private Map services= new HashMap();
   public static Object getService(String key) {
     return soleInstance.services.get(key);
   }
   public void loadService (String ket, Object service) {
     services.put(key, service);
   }
```

配置包括通过合适的键来加载一个服务。

```
class Tester...
  private void configure() {
    ServiceLocator locator = new ServiceLocator();
    locator.loadService("MovieFinder", new ColonMovieFinder("movies1.txt"));
    ServiceLocator.load(locator);
  }
```

我通过相同的键使用服务。

```
class MovieLister...
   MovieFinder finder = (MovieFinder) ServiceLocator.getService("MovieFinder");
```

总体来说我不喜欢这种方法。即使很灵活，但不是很明显。我只能通过文本键来发现服务。我更喜欢明显的方法，因为那更容易通过接口定义发现他们。

##### Avalon同时使用一个定位器和注入器

依赖注入和服务定位不是相互排斥的概念。一个好的例子便是同时使用两者的Avalon框架。Avalon使用服务定位器，但是使用注入来告诉哪里发现定位器。

xxx发给我一个使用Avalon的简单版本运行的例子。

```
public class MyMovieLister implements MovieLister, Serviceabel {
  private MovieFinder finder;

  public void service( ServiceManager manager ) throws ServiceException {
    finder = (MovieFidner)manager.lookup("finder");
  }
}
```

这个服务方法是一个接口注入的例子，允许指定的容器注入服务管理者到MyMovieLister。服务管理者便是一个服务定位者的例子。在这个例子里，lister没有将管理者储存在域中，而是立即用其来查找需要储存的finder。

### 决定使用哪个选择

到目前为止，我关注于我怎么认识这些模式以及他们的变体。现在我可以开始讨论他们的益处和缺点来帮助我们知道在什么时候使用哪一个。

##### 服务定位器vs依赖注入

最基本的选择是在服务定位器和依赖注入之间做选择。第一个点便是他们的实现都提供了在直接例子中缺失的，基础的解耦-两种应用代码都是相对于服务的接口，有着独立于具体的实现。他们间重要的不同点在于提供给应用程序类的实现。服务定位器来说，应用程序类直接显式通过消息来得到它。而注入则没有显式请求，服务就出现在应用程序类中-因此反转了控制。

反转控制是许多框架共有的特性，但是其也是有代价的。反转控制会逐渐变得难以理解，并当你尝试调试时会产生问题。所以总的来说，我会回避他，除非我需要。这不是说他是一种坏东西，只是我认为其需要让选择变得更加直接。

最主要的不同便是每个用户如果使用服务定位器，就会依赖定位器。定位器可以对其他实现隐藏依赖，但是你需要看到定位器。所以定位器和注入器的选择决定于依赖是不是个问题。

使用依赖注入能够帮助我们更容易知道组件依赖是什么。使用依赖注入时你只需要查看注入机制，像是构造器，还有看见依赖。当使用服务定位器时，你不得不为了请求定位器而查找源代码。现在集成开发编辑器使查找引用变得容易了许多，但是仍然比只是看构造器或者设置器方法困难。

这其中很大一部分依赖于用户服务的特性。如果你在建造一个拥有很多使用服务的类的应用的话，应用程序类对定位器的依赖不是大问题。在我给予我朋友一个电影列表的例子里，使用一个服务定位器很好。它们只需要配置定位器使其连接上正确的服务实现，或者通过一些配置代码或通过配置文件。在这种场景，我不会注入反转提供了什么重要的。

主要的不同是当lister是一个别人正在编写的，我提供给应用的组件。在这种情况下，我不知道顾客会使用哪些服务定位器的apis。每一个客户都有可能有其不兼容服务定位器的地方。我可以通过使用隔离不同的接口来解决。每一个顾客可以编写一个适配器来使用我的接口适应他们的定位器。只要适配器出现，对于定位器的直接连接的容易程度开始降低。

既然对于一个注入器你没有一个从组件到注入器的依赖，组件只要已经被配置了就不能包含进一步的更多地服务。人们更喜欢依赖注入的一个普遍的原因是其让测试更加的容易。这里的重点是做测试，你需要stubs和mocks很容易代替真实的服务实现。但是在这里服务定位器和依赖注入没什么区别：两者都可以stubbing。我怀疑这个现象是来自那些项目的人们不尽力确保服务定位器可以被容易替代的结果。这里持续测试起作用了，如果你不能为测试很容易stub服务，这暗示了你设计的一个严重的问题。

当然，测试问题会因为组件环境的添加变得恶化，例如Java的EJB框架。我的观点是这类框架需要最小化他们对应用程序代码的影响，特别是不能减慢关于编辑-执行的做事闭环。使用插件来代替重量级主键很好地帮助了这个过程，比如对测试驱动开发就很重要。

所以主要的问题是编写需要在程序中用到的代码的人们在写者的控制之外。在这种情况下，即使是最小的猜想，服务定位器是一个问题。

##### 构造器vs设置器注入

对于服务结合，你总是不得不有一些习惯来使事情结合到一起。注入的主要优点使其只需要十分简单的习惯-只是构造器和设置器注入。你不用在你的组件里做什么奇怪的事情，而且对于注入器来说，所有事情的配置也是很直接的。

接口注入会比较侵入代码，因为你不得不写很多接口来得到整理。对于容器需要的一小部分接口，像是Avalon的方法，这也不是太糟糕。但是需要很多工作来组装组件和依赖，这也是为什么现在很多轻量级容器只支持设置器和构造器注入。

在设置器和构造器之间的选择是很有趣的，因为他反映了一个更普遍的关于面向对象编程的问题-你需要在构造器还是设置器里初始化域值。

我的建议是默认在构造器时候创建对象。这个建议来自Kent Beck的Smalltalk最佳实践模式：构造器方法和构造器参数方法。伴随参数的构造器在很明显的地方给你一个清楚的，为什么创建对象的陈述。如果还有其他方法，创建多个构造器会显示不同的组合。

另一个构造器初始化的优点是其允许你通过不提供设置器来隐藏任何不可变的域。我认为这是很重要的-如果一些事不应该改变，于是没有设置器是很好的。如果使用设置器来初始化，这将会变成一个痛点。

但是任何情况都有例外。如果你你有很多构造器参数看起来很乱，特别是没有关键字参数的语言。一个长构造函数通常是一个承担太多任务的对象的标志，也意味着需要分离，但是也有情况你需要这样。

如果你有多种方法来构造一个有效的对象，这很难从构造器显示出来，因为构造器只是能够在参数的数量和类型上变化。这也就是工厂方法起作用的地方，他们可以使用私有构造器和设置器的结合来实现工作。经典的对于组件组装的工厂函数的问题是他们通常被看成是静态方法，而且你也没办法在其上定义接口。你能够创建一个工厂类，但是然后就变成了另一个服务实例。一个工厂服务是一个好的策略，但是你还是不得不使用其中一种技术来实例化工厂。

如果你有简单的参数，像是字符串，构造器还会有问题。使用设置器注入，你可以给每个设置器一个名字来标识字符串应该干些什么。而构造器你只是依赖于位置，难以去追踪。

不管这些缺点，我还是更倾向从构造器注入开始，但是一旦我上述的问题出现的话，就要准备好转换到设置器注入。

这个主题引发了一些在很多提供将依赖注入作为他们框架一部分的团队中的争论。但是看起来大多数建造这些框架的人已经意识到支持这两种机制都十分重要，甚至人们已经倾向于其中的一种方法。

##### 代码或者配置文件

一个分开的但是经常被合并的问题是在启动服务的api时究竟要用配置文件还是代码。对于大多数应用来说，他们可能会被部署到很多地方，所以一个分离的配置文件通常更有用。大多数时间这会是一个XML文件，也有道理。但是有些情况下使用程序代码来组装会更容易。一种情况是一个并没有很多部署变量的简单应用。在这种情况下，代码会比分离的配置文件更清楚。

一个相反的情况是组装比较复杂，包含了条件步骤。一旦你熟悉一种编程语言，XML开始被替代，于是使用一门有全部语法的，容易编写清楚的程序的真实的语言会是更好的选择。你将会编写一个建造者类来执行组装。如果你拥有不同的建造者场景，你可以提供一些建造者类，然后用一个简单的配置文件来在选择他们。

我经常认为人们对定义配置文件过于热切。编程语言经常构建一个直接而有效的配置机制。现代语言能够很容易编译小的程序集，然后用来为较大的系统组装插件。如果汇编是个痛点，脚本语言也是可以的。

人们经常认为配置文件不应该用一门编程语言因为他们需要被非程序员编辑。但是这种情况发生多吗？人们真的指望非程序员来改变一个复杂服务端应用的事务隔离级别？非语言配置文件是很容易。如果他们变得复杂的话，那是时候思考使用合适的编程语言了。

配置文件是在java世界的一个杂音，每一个组件都有和其他组建不同的配置文件。如果你使用很多组件的话，你能够很容易为了保持配置文件的同步而崩溃。

我的建议是总是提供一个可编程接口来实现所有配置，然后把分离的配置文件作为可选择的特性。你可以很容易地使用编程接口构建配置文件处理机制。如果你正在编写一个组件，可以将选择编程接口，你的配置文件格式，或者编写他们客户自己的配置文件格式然后绑定到编程接口的选择交给用户。

##### 从使用分离配置文件

这里面重要的主题是确保服务的配置和使用是分离的。实际上，这是一个基础的设计原则，也就是将接口和实现分离。这也是在面向对象编程中什么时候条件逻辑决定实例化哪个类，然后通过多态来实现而不是重复的条件代码。

如果这个分离在一个单一代码基础下是有用的，那当你在使用像是组件和服务等外部元素是就显得格外重要了。第一个问题便是你是否希望延迟在部署时实现类的选择。如果这样，你需要使用一些插件的实现。一旦你在使用插件，把和应用程序剩下部分分离组装变得很重要，所以你可以很容易在不同的部署下代替不同的配置。你怎么实现这个是次要的。这个配置机制可以配置一个服务定位器。或者使用注入来直接配置对象。

### 更进一步

在这篇文章中，我集中讨论在使用依赖注入和服务定位器的服务配置的基本问题上。有一些更多的主题也是我们应该注意的，但是我还没时间去研究。特别是生命周期行为。一些组件有独立的生命周期事件：实例的启动和结束。另一个主题是面向切面思想在容器中的应用。即使我还没考虑这个主题，我还是希望再写一些在后续。

你可以发现许多这些想法，通过轻量级容器的网站。观看picocontainer和spring的网站，将会引导你到更多讨论的问题中。

### 总结

当前很多轻量级容器都有共同的底层模式来实现怎么组装服务-依赖注入模式。依赖注入是不同于服务定位的很好的选择。当构建应用程序类时两者会有不同，但是我认为服务定位略占优势，因为其很直接。然而如果你在建造被多个应用程序使用的类时，依赖注入是更好的选择。

如果你使用依赖注入，会有很多形式你可以选择。我建议你使用构造器注入，除非你使用它时遇到一些问题，然后转移到使用设置器注入。如果你在选择建造还是包含一个容器，那就使用两者都实现的容器。

在服务定位器和依赖注入间的选择对比起分离在应用中使用服务的服务配置原则来说不是那么重要了。