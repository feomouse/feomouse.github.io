---
title: 基于在需求分析模型和web框架指定设计模型间的映射规则的开发经验
categories: 软件构造思想
---

### 原作者
* Hirotaka Okuda
* Shinpei Ogata
* Saeko Matsuura

### 原文链接
https://springerplus.springeropen.com/articles/10.1186/2193-1801-2-123

### 摘要
模型驱动开发是开发出高质量软件系统的一种可靠的方式。我们已经提议一种利用Unified Modeling Language(UML)来作为模型驱动的需求分析方式。我们的方法的主要特性是通过UML需求分析模型来自动生成一个web用户接口原型，以此我们可以确定我们输入输出数据的有效性以及通过直接操作原型确定页面之间的转换。我们提议在基于需求分析模型的基础上，对不同的web应用框架实现上有一个映射规则，也为了提高从一个有效需求分析模型到最终产品的可追踪性。这篇论文讨论了通过此方式开发出的，最近工作在我们公寓的团队工作支持系统。

##### 关键词 
web frameworks, unified modeling language, requirements analysis model

### 介绍
当今许多有用的服务和产品像是计算机系统需要开发者有效地开发一个高质量的系统，所以他们可以迎合不同的知识背景的用户，不同的使用情况，不同的输入输出设备像是智能电话和个人计算机。为了确保这样的一种开发，软件在整个生命周期的可追踪性是很重要的，而且模型驱动开发方式是一种可靠的方式。

我们已经提议一种使用UML的基于模型驱动的需求分析方法(Ogata & Matsuura 2008; 2010a)。我们方法的主要的特性是通过UML需求分析模型来自动生成web用户接口原型，所以我们通过直接操作原型，可以确保对每个页面和页面转换的输入输出数据的有效性。我们已经展示出通过实现需求分析模型使最终产品的需求分析拥有可追踪性(Ogata & Matsuura 2010b),但是这样一种系统性方法需要需求分析模型和设计模型的一个映射规则。

近些时间，大多数web应用是通过这种web应用程序框架，好似struts, play framesworks来开发的。一个web应用程序框架是一系列可重用的指定web应用构造类库。通过开发者定义应用程序具体的类从而开发出最后的web应用程序。因此开发者被要求针对每种具体的框架像是struts来了解知道特定的web应用构建机制。这样的一种具体的基于每个框架实现的知识依赖好像打扰了有效率的高质量开发。

这篇论文旨在基于需求分析模型的设计信息来得到一个映射规则，而不依赖于指定的web应用程序框架实现，甚至可以自动为每个框架生成指定代码。

### 需求分析方法

##### 需求分析方法的模型特性

在需求分析的情况下，开发者从消费者那提取出系统开发的需求，通过制作非正式文档来指定这些需求。近些时间，许多开发者已经开始使用UML，所以需求可以被更加正式地定义。我们已经提议一种使用UML来得到模型驱动的需求分析方法。我们在使用用例分析的同时也分析服务的功能需求。特别是因为用户最想要做的很明显地表现在用户和系统的交互中，我们的方法目的就是清楚地模型化这种交互。

为了正确地展示，我通过以下四个观点，来指定一个作为服务的事务过程。

* 基于事务规则，为了使服务正确地执行，需要哪些输入数据和条件？
* 为了观察事务规则，哪种类型的条件应该需要以防止系统不执行服务。更具体，系统应该怎么对待这些异常情况？
* 通过这些条件，为了执行服务，什么类型的行为是需要的？
* 这些行为会产生什么类型的数据？

基于以上提及的四点，为了完成需要的目标事务的输入业务流程和事务实体数据，我们通过UML活动图和类图来表示。

一个活动图不止指定了通常的和异常的行为流程，而且还指定了和其相关的数据流。一个行为通过行为节点来定义，数据通过在类图里被分类了的类的对象节点表示。通过这两种图，我们可以将业务流程和数据建立联系。这是我们的方法关于活动图和流程图的众多特性之一。特别是为了正确地执行服务，在用户和系统交互过程中，用户输入，条件判断，输出涉及到很多不同的流程和数据。

第二个特性是活动图有三种区分，分别为用户，交互和系统。这是因为这些区分是我们能过分辨以下活动；用户输入活动，用户和系统不同条件下的交互活动和结果输出。

第三个特性是对于每个活动，我们都用对象图来定义具体的数据，因为具体有效的数据使确定业务处理过程更容易。

第四个特性是组成用html编写的web页面的原型使自动从这些图表中产生的。这样一种最终产品的原型使消费者顾客可以很容易地将事务流和数据建立连接。生成的原型描述了需要的目标系统，除了用户接口表现和内部业务逻辑处理。再者，原型使开发者更坚定地理解模型和最终系统的一致性。开发者伴随着需求分析定义了三种类型的图表，通过不同的观点来表示行为流，数据流和结构，和具体的值。自动生成的原型使顾客可以很容易地理解顾客的模型和目标系统之间的一致性。为了能够完全理解每一种图表和目标系统间的一致性，一个原型可以被生成以满足开发者任何时候对需求分析理解。需求分析模型通过使用一种模型工具来被定义。

在顾客满意地表示出他们对需求原型的肯定的阶段后，我们可以说顾客通过实际的用处的角度来验证规格说明书是否满足他们的期望。

但是，对开发者来说可以验证规格说明书以此来确定规格书的可行性是十分重要的。为了做到这一点，开发者必须确保一系列行为和数据流在系统活动图分区中能够从指定的输入数据产生期望的输出数据。系统原型帮助开发者确定以下事实。

* 用户定义的输入数据能够转换成系统中的实体数据
* 已经存在的实体数据必须通过其他使用用例产生，还有以上提及的实体数据能够通过指定的行为序列产生目标输出数据

如果可以这样考虑，开发者便能够定义实体类了。

###### 需求分析模型指定的组件

在使用我们的需求分析方法过后，我们可以获取以下指定的组件。

1. 实体类：一集合实体类在全部系统活动图分区中变成持久化数据的继任者。
2. 输入输出数据类：一集合输入输出数据类在用户或交互活动图分区中决定服务的一系列页面和每个页面的结构。
3. 触发和处理流程：每个活动图决定一系列活动服务处理流程。一个处理流程被通过在一个输入类中的触发事件执行时调用的一系列在系统分区的动作节点和对象节点
4. 异常流：当对于一个输入数据发生异常时，活动图决定系统的处理流程。

### web应用开发中的问题

当今许多web应用程序给予我们更加富有的客户端服务技术像是css,Flash,Java Script and Ajax, etc.服务端服务也是通过像是PHP,JSP,ASP.NET,CGI,etc技术开发。再者，数据持久化机制已经通过DBMS,RDBMS开发。web应用框架旨在减轻大量和普通活动相关的功能，例如提供模板框架库，数据库访问，安全管理等。结果是我们能够不关心web应用，而关注于应用的逻辑。大多数web应用由客户端，服务端，持久端，也就是被称为'Model-View-Controller'模式来提升应用的相互独立性。

但是不同的框架拥有不同的库，所以开发者有责任利用不同的表达来实现系统。再者，用法依赖于开发者的意图，所以有时他们会定义一些不明晰的MVC model实现并影响到可维护性。特别是他们有时由于缺少清晰的引导而没法给出一个合适的，用户和系统间交互角色。为了提高频繁改动的web应用的可维护性，便需要以一个清晰的映射规则规定需求组件和框架热点间的关系。

我们建议在以上提及的组件应用一个在交互时有明确指导方针，应用需求分析方法，一个独立于不同实现的web框架指定的设计模型的映射规则。

### 在需求分析模型和web框架指定模型间的映射规则

我们定义了一个在需求组件和web框架热点间的联系，也描述了怎么通过组件设计这些热点。

##### web框架指定的设计模型

图一显示了和指定需求分析模型一致的web框架指定的设计模型。其中包含了四种角色，视图，视图控制器，逻辑控制器和模型。视图嵌入到与在用户和交互部分的输入输出数据需求分析一致的每一页。视图控制器嵌入四种角色，验证输入数据，转换输入数据到逻辑控制器，解耦传输的对象和在视图控制器输出的数据，控制被触发器触发的过程。逻辑控制器嵌入在系统部分的控制需求，也是被触发器触发的一种处理流程。那是一系列嵌入到在系统部分的行动的方法。模型嵌入到在系统部分的实体类。因为逻辑控制器和模型时在框架中分离实现的，所以他们可以成为可复用的组件。另一方面，视图和视图控制器应该对每个框架指定以上涉及的角色的规则。

而且我们需要设计在执行的时候持久层数据的一致，所以全部服务能够被在保持一致的情况下被多个并发用户同时使用。在系统部分的全部活动模式里的实体类集合能够成为持久对象的代替者。从这个观点来看，我们不得不在系统部分的活动图里指定每个对象的角色。在活动图里，一个对象节点代表一个在一些特定区域的有效的类的实例数据。这些区域如下，被在处理流程里的处理单元和一个多并发用户的执行过程分类。

* 数据库的持久：将会被多个并发用户共享的持久层数据需要被储存在数据库里。
* 对话的状态：在单个用户的执行流程里的对话数据需要被标识，所以才可和别人保持一致性
* 页面事务的对话：在一个服务的另一个处理流程的对话数据需要传递标识不同的数据，以便于在单个用户执行保持一致
* 临时性：临时性数据只在一个处理流程里有效。其持有get/post方法的处理流程的输入输出数据。

##### web框架的组件指定设计模型

图2显示视图控制器和逻辑控制器的元数据模型。

在需求分析模型里的一个处理流程拥有一个在输入类的触发器里一致的名字，组成一些实体的一系列活动。在系统分区的每一个活动被分配成一个事务逻辑方法与一个合适的实体类，也就是一个实体活动。一个活动描述的描述词语是对一个实体类分配的暗示。一个处理流程也有一些和事务规则一致的逻辑异常处理。逻辑异常对象的数量和在需求分析模型的活动图的异常流的数量是一致的。

为了在视图控制器和逻辑控制器间建立联系，数据传输类被在需求分析模型里的输入输出数据类所产生。传输类通过移除一些输入输出数据类的触发信息所定义，其域需要被指定为原始类型和字符串类型，以不依赖于任何框架。也就是说，其在视图控制器和逻辑控制器间充当了一个中介者的角色，每一个处理流程也有充当输入输出书的传输对象。

基于指定的实体对象，对象管理者承担管理上述提及的对话数据的责任。数据库管理是一个管理储存在数据库里的持久化数据的类。

我们已经建议一个约束表格，代表输入数据的条件，异常处理和信息。基于约束表格，在活动部分的异常检查活动被一些输入数据的不正确情况下指定。我们可以称其为验证。验证是通过使用每个框架的异常处理机制实现的。

### 实现实验和讨论

##### 开发的大纲

我们已经发展出一系列团队工作支持系统，旨在通过我们的方法为基于学习项目提供一个课程。这个系统称为GWSS。参加这个课程的大约有25个学生和1个教室和一些助教。学生被分成几组。每一个参与者基于角色拥有其自身的权利，除了助教有和教室相同的权限。系统拥有以下三个用例，以便在团队工作时来管理任务。

* 公告板： 其被用在团队成员和在学生和任教成员的QA的团队讨论中。
* 会议的时间：其旨在共享许多团队成员在开发时的信息，以及记录讨论结果。
* 任务的报告：报告的目的是学生可以计划自己在接下来时间的任务，并报告结果。

参与者被给予的权限如表一所示。GWSS还拥有一些功能登录系统，以及管理参与者学生的信息。

##### 开发过程和环境

我们已经通过使用Play框架产生了实现经验，MYSQL 5.5和Hibenate实现数据库管理和在模型和数据库间的O/R映射。两个有一定的软件开发经验的毕业的学生在三周内开发了GWSS。系统总共有4946行。表格2显示了RA模型的组件的数量和最终的源代码。

我们通过我们的模型驱动需求分析方法定义了GWSS的需求分析模型。分析结果模型包含了12用例，对应12个活动图，16个实体类和33个输入输出类。平均在一个活动图的活动节点的数量是21。平均在一个类中的属性是3个。作为参数的类的数量代表在定义web框架制定设计模型加上的类。全部方法都定义在系统部分的活动上，和触发器和处理流程一致。在源代码里方法数量增加是因为一些需要定义业务逻辑和功能的方法需要被定义。特性减少的原因是就大多数在输入输出类的特性被转成HTML文件的形式。

和映射规则一致，我们定义了web框架指定设计模型。

首先，我们指定了在活动图的系统部分的每一个对象的角色。其次，骨架代码由一系列和处理流程中的活动的一致的方法生产，也就是称为触发器的方法。再者，输入输出类定义写成HTML文件的视图，所以其包含了触发器，输入输出数据，也就是视图控制器角色。

##### BBS实现例子

图三表达了活动图的一部分，为了浏览BBS。图四展示了被定义在活动图里系统部分的类。我们指定了在图表里每一个对象的角色。

* Filter是一个临时的角色，因为其只在处理流程里有效。
* User是数据库的持久化，为了在其他用例里创建和更新，也就是说，在这个用例里，User被用来标识一个执行进程主体。也就是User在这个例子里，是作为对话状态的角色的。
* 因为ParentPost和Group是在不同用例中都有效的，他们是作为在数据库里持久化的角色的。

再者，一个对象节点在交互部分和系统部分的交界线间能够清楚地指定处理流程的输入数据。一些对象节点，作为输入，会被作为处理流程的输出数据。

然后，我们会解释怎么通过定义web框架指定设计模型来驱动以下Play框架的源码。

在图三，一个vieewBBSProcess的方法表示了处理流程。在边界线的一个对象节点是一个对象的参数，也是Filter。返回类型是Map<String, Object>，因为这个方法返回很多作为输出被对象节点代表的值。源码第二行表达了返回值的描述。在源码第8,11,14,15行，每一个输出的对象节点的值被储存在Map里。全部写在图三气球里的数字和源码中行数是一致的。在图三第七行表达了分页活动。我们通过在play框架里的第三方方法实现了活动。

play框架提供指定的方法引索来展示到启动BBS的顶页。视图控制器被在以下源码中的这个方法定义。源码的第二行表达了逻辑控制器的启用。在第五行后，全部对象都被用来阐释需要的输出数据。在20行后，这些数据被转换类转成另一种数据。22行表达了一个play框架指定的方法，以用来返回需要展示BBS的数据。自22行到26行，展示了通过使用方法库来分页的过程。

### 讨论

